// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"reflect"
	"strconv"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/ikasamt/zapp/zapp"

	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
)

func (any *User) AsJSON() gin.H {
	return gin.H{
		"id":         any.ID,
		"created_at": any.CreatedAt,
		"updated_at": any.UpdatedAt,
	}
}

func (any *User) Set(c *gin.Context) {
	r := reflect.ValueOf(any)
	method := r.MethodByName("Setter") // これは個別に定義したいので回避
	if method.IsValid() {              // メソッドがある場合のみ実行
		method.Call([]reflect.Value{reflect.ValueOf(c)})
	}
}

func (any *User) Validate() {
	r := reflect.ValueOf(any)
	method := r.MethodByName("Validations") // これは個別に定義したいので回避
	if method.IsValid() {                   // メソッドがある場合のみ実行
		response := method.Call(nil)[0]
		// nilじゃなければ
		if reflect.ValueOf(response.Interface()).IsValid() {
			any.errors = response.Interface().(error)
		}
	}
}

func (any *User) Diff() gin.H {
	// 現在と元のデータの違い
	var afterJSON gin.H
	j := zapp.CallMethod(any, `AsJSON`, nil)
	if j != nil {
		afterJSON = j.(gin.H)
	}
	if any.ID == 0 {
		return afterJSON
	}

	diff := make(gin.H)
	for k, before := range any.beforeJSON {
		after := afterJSON[k]
		if !reflect.DeepEqual(before, after) {
			diff[k] = []interface{}{before, after}
		}
	}
	//
	return diff
}

func (any *User) GetErrors(key string) []string {
	if any.errors == nil {
		return []string{}
	}

	// エラー文字列を分割する
	_errors := make(map[string][]string)
	for _, e := range strings.Split(any.errors.Error(), `;`) {
		tmp := strings.Split(e, `:`)
		k := strings.TrimLeft(tmp[0], " ")
		v := strings.TrimLeft(tmp[1], " ")
		v = strings.TrimRight(v, ".")
		switch v {
		case `must be in a valid format`:
			v = `正しい形式ではありません`
		case `cannot be blank`:
			v = `必須項目です`
		}
		if _errors[k] == nil {
			_errors[k] = []string{}
		}
		_errors[k] = append(_errors[k], v)
	}
	return _errors[key]
}

func (any *User) GetValueAndName(key string) (value reflect.Value, name string) {
	value = reflect.ValueOf(any).Elem().FieldByName(key)
	name = strcase.ToSnake(strings.Replace(key, "ID", "Id", 1))
	return
}

func (any *User) CheckboxField(key string) template.HTML {
	value, name := any.GetValueAndName(key)

	if value.Interface().(bool) {
		return template.HTML(fmt.Sprintf("<input type='checkbox' name='%s' checked='checked' />", name))
	}
	return template.HTML(fmt.Sprintf("<input type='checkbox' name='%s' />", name))
}

func (any *User) TextField(key string) template.HTML {
	value, name := any.GetValueAndName(key)

	inputText := fmt.Sprintf("<input type='text' name='%s' value='%v' />", name, value)
	if messages := any.GetErrors(key); len(messages) > 0 {
		retval := "<div class='field_with_errors'>"
		retval += inputText
		retval += "<br/>"
		retval += fmt.Sprintf("<span class='field_with_errors_message'>%s</span>", strings.Join(messages, ","))
		retval += "</div>"
		return template.HTML(retval)
	}
	return template.HTML(inputText)
}

func (any *User) SelectField(key string, options string) template.HTML {
	_, name := any.GetValueAndName(key)

	inputText := ``
	inputText += fmt.Sprintf("<select class='select2' name='%s' style='width: 100%%'>", name)
	inputText += options
	inputText += "<br/>"
	inputText += "</select>"
	if messages := any.GetErrors(key); len(messages) > 0 {
		retval := "<div class='field_with_errors'>"
		retval += inputText
		retval += fmt.Sprintf("<span class='field_with_errors_message'>%s</span>", strings.Join(messages, ","))
		retval += "</div>"
		return template.HTML(retval)
	}
	return template.HTML(inputText)
}

// SaveUser 履歴保存
func SaveUser(db *gorm.DB, any *User) *gorm.DB {
	history := zapp.History{}
	history.Model = reflect.TypeOf(any).Elem().Name()
	history.InstanceID = any.ID
	bytes, _ := json.Marshal(any.Diff())
	history.Data = string(bytes)
	if history.Data != `{}` {
		db.Debug().Save(&history)
	}
	db.Debug().Save(&any)
	return db
}

func searchUsers(c *gin.Context, any *User) (count int, instances []User) {
	// DB接続を取得
	db := GetMasterDBInstance()
	defer db.Close()

	// 検索条件
	db = db.Debug()

	method := zapp.GetMethod(any, `Search`)
	if method.IsValid() {
		db = method.Call([]reflect.Value{reflect.ValueOf(db)})[0].Interface().(*gorm.DB)
	}
	perPage, err := strconv.Atoi(zapp.GetParams(c, `per_page`))
	if err != nil {
		perPage = zapp.DefaultPerPage
	}
	page, err := strconv.Atoi(zapp.GetParams(c, `page`))
	if err != nil {
		page = 0
	}

	// 件数
	db.Model(any).Count(&count)
	// 検索実行
	db.Offset(page * perPage).Limit(perPage).Order(`id DESC`).Find(&instances)
	return count, instances
}

// List
func adminUserListHandler(c *gin.Context) {
	instance := &User{}
	instance.Set(c)
	totalCount, instances := searchUsers(c, instance)
	context := map[string]interface{}{"instances": instances, "instance": instance, "total_count": totalCount}
	zapp.RenderAdmin(c, context)
}

// New
func adminUserNewHandler(c *gin.Context) {
	instance := User{}
	zapp.RenderAdmin(c, map[string]interface{}{"instance": instance})
}

// Edit
func adminUserEditHandler(c *gin.Context) {
	instance, _ := getUser(c)
	zapp.RenderAdmin(c, map[string]interface{}{"instance": instance})
}

// Show
func adminUserShowHandler(c *gin.Context) {
	instance, err := getUser(c)
	if err != nil || instance.ID == 0 {
		log.Println(err)
	}
	zapp.RenderAdmin(c, map[string]interface{}{"instance": instance})
}

// Create
func adminUserCreateHandler(c *gin.Context) {
	// DB接続を取得
	db := GetMasterDBInstance()
	defer db.Close()

	instance := &User{}
	instance.Set(c)
	instance.Validate()
	if instance.errors != nil {
		zapp.RenderAdmin(c, map[string]interface{}{"instance": instance}, `new`)
		return
	}

	// 値の更新 ------------------------------------------>
	log.Println(`-----`)
	log.Println(instance)
	log.Println(`-----`)
	SaveUser(db, instance)
	// <-------------------------------------------------

	// 完了ページへリダイレクト
	message := fmt.Sprintf("%v 追加しました", instance)
	zapp.SetFlashMessage(c, message)
	controllerName, _ := zapp.ExtractControllerActionName(c)
	backURL := fmt.Sprintf("/admin/%s/", controllerName)
	c.Redirect(http.StatusFound, backURL)
}

func (any *Organization) AsJSON() gin.H {
	return gin.H{
		"id":         any.ID,
		"created_at": any.CreatedAt,
		"updated_at": any.UpdatedAt,
	}
}

func (any *Organization) Set(c *gin.Context) {
	r := reflect.ValueOf(any)
	method := r.MethodByName("Setter") // これは個別に定義したいので回避
	if method.IsValid() {              // メソッドがある場合のみ実行
		method.Call([]reflect.Value{reflect.ValueOf(c)})
	}
}

func (any *Organization) Validate() {
	r := reflect.ValueOf(any)
	method := r.MethodByName("Validations") // これは個別に定義したいので回避
	if method.IsValid() {                   // メソッドがある場合のみ実行
		response := method.Call(nil)[0]
		// nilじゃなければ
		if reflect.ValueOf(response.Interface()).IsValid() {
			any.errors = response.Interface().(error)
		}
	}
}

func (any *Organization) Diff() gin.H {
	// 現在と元のデータの違い
	var afterJSON gin.H
	j := zapp.CallMethod(any, `AsJSON`, nil)
	if j != nil {
		afterJSON = j.(gin.H)
	}
	if any.ID == 0 {
		return afterJSON
	}

	diff := make(gin.H)
	for k, before := range any.beforeJSON {
		after := afterJSON[k]
		if !reflect.DeepEqual(before, after) {
			diff[k] = []interface{}{before, after}
		}
	}
	//
	return diff
}

func (any *Organization) GetErrors(key string) []string {
	if any.errors == nil {
		return []string{}
	}

	// エラー文字列を分割する
	_errors := make(map[string][]string)
	for _, e := range strings.Split(any.errors.Error(), `;`) {
		tmp := strings.Split(e, `:`)
		k := strings.TrimLeft(tmp[0], " ")
		v := strings.TrimLeft(tmp[1], " ")
		v = strings.TrimRight(v, ".")
		switch v {
		case `must be in a valid format`:
			v = `正しい形式ではありません`
		case `cannot be blank`:
			v = `必須項目です`
		}
		if _errors[k] == nil {
			_errors[k] = []string{}
		}
		_errors[k] = append(_errors[k], v)
	}
	return _errors[key]
}

func (any *Organization) GetValueAndName(key string) (value reflect.Value, name string) {
	value = reflect.ValueOf(any).Elem().FieldByName(key)
	name = strcase.ToSnake(strings.Replace(key, "ID", "Id", 1))
	return
}

func (any *Organization) CheckboxField(key string) template.HTML {
	value, name := any.GetValueAndName(key)

	if value.Interface().(bool) {
		return template.HTML(fmt.Sprintf("<input type='checkbox' name='%s' checked='checked' />", name))
	}
	return template.HTML(fmt.Sprintf("<input type='checkbox' name='%s' />", name))
}

func (any *Organization) TextField(key string) template.HTML {
	value, name := any.GetValueAndName(key)

	inputText := fmt.Sprintf("<input type='text' name='%s' value='%v' />", name, value)
	if messages := any.GetErrors(key); len(messages) > 0 {
		retval := "<div class='field_with_errors'>"
		retval += inputText
		retval += "<br/>"
		retval += fmt.Sprintf("<span class='field_with_errors_message'>%s</span>", strings.Join(messages, ","))
		retval += "</div>"
		return template.HTML(retval)
	}
	return template.HTML(inputText)
}

func (any *Organization) SelectField(key string, options string) template.HTML {
	_, name := any.GetValueAndName(key)

	inputText := ``
	inputText += fmt.Sprintf("<select class='select2' name='%s' style='width: 100%%'>", name)
	inputText += options
	inputText += "<br/>"
	inputText += "</select>"
	if messages := any.GetErrors(key); len(messages) > 0 {
		retval := "<div class='field_with_errors'>"
		retval += inputText
		retval += fmt.Sprintf("<span class='field_with_errors_message'>%s</span>", strings.Join(messages, ","))
		retval += "</div>"
		return template.HTML(retval)
	}
	return template.HTML(inputText)
}

// SaveOrganization 履歴保存
func SaveOrganization(db *gorm.DB, any *Organization) *gorm.DB {
	history := zapp.History{}
	history.Model = reflect.TypeOf(any).Elem().Name()
	history.InstanceID = any.ID
	bytes, _ := json.Marshal(any.Diff())
	history.Data = string(bytes)
	if history.Data != `{}` {
		db.Debug().Save(&history)
	}
	db.Debug().Save(&any)
	return db
}

func searchOrganizations(c *gin.Context, any *Organization) (count int, instances []Organization) {
	// DB接続を取得
	db := GetMasterDBInstance()
	defer db.Close()

	// 検索条件
	db = db.Debug()

	method := zapp.GetMethod(any, `Search`)
	if method.IsValid() {
		db = method.Call([]reflect.Value{reflect.ValueOf(db)})[0].Interface().(*gorm.DB)
	}
	perPage, err := strconv.Atoi(zapp.GetParams(c, `per_page`))
	if err != nil {
		perPage = zapp.DefaultPerPage
	}
	page, err := strconv.Atoi(zapp.GetParams(c, `page`))
	if err != nil {
		page = 0
	}

	// 件数
	db.Model(any).Count(&count)
	// 検索実行
	db.Offset(page * perPage).Limit(perPage).Order(`id DESC`).Find(&instances)
	return count, instances
}

// List
func adminOrganizationListHandler(c *gin.Context) {
	instance := &Organization{}
	instance.Set(c)
	totalCount, instances := searchOrganizations(c, instance)
	context := map[string]interface{}{"instances": instances, "instance": instance, "total_count": totalCount}
	zapp.RenderAdmin(c, context)
}

// New
func adminOrganizationNewHandler(c *gin.Context) {
	instance := Organization{}
	zapp.RenderAdmin(c, map[string]interface{}{"instance": instance})
}

// Edit
func adminOrganizationEditHandler(c *gin.Context) {
	instance, _ := getOrganization(c)
	zapp.RenderAdmin(c, map[string]interface{}{"instance": instance})
}

// Show
func adminOrganizationShowHandler(c *gin.Context) {
	instance, err := getOrganization(c)
	if err != nil || instance.ID == 0 {
		log.Println(err)
	}
	zapp.RenderAdmin(c, map[string]interface{}{"instance": instance})
}

// Create
func adminOrganizationCreateHandler(c *gin.Context) {
	// DB接続を取得
	db := GetMasterDBInstance()
	defer db.Close()

	instance := &Organization{}
	instance.Set(c)
	instance.Validate()
	if instance.errors != nil {
		zapp.RenderAdmin(c, map[string]interface{}{"instance": instance}, `new`)
		return
	}

	// 値の更新 ------------------------------------------>
	log.Println(`-----`)
	log.Println(instance)
	log.Println(`-----`)
	SaveOrganization(db, instance)
	// <-------------------------------------------------

	// 完了ページへリダイレクト
	message := fmt.Sprintf("%v 追加しました", instance)
	zapp.SetFlashMessage(c, message)
	controllerName, _ := zapp.ExtractControllerActionName(c)
	backURL := fmt.Sprintf("/admin/%s/", controllerName)
	c.Redirect(http.StatusFound, backURL)
}
